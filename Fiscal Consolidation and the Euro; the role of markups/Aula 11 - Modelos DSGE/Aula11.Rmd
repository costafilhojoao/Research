---
title:  | 
        | Econometria Bayesiana - Aula 11
subtitle: 'This is the subtitle'  
author: 
- "João Ricardo Costa Filho[^JRCF]"
date: Outubro-Dezembro, 2019
#date: \today
#thanks: "We thank XXXX for their helpful comments. All the remaining errors are our entire responsibility."
abstract: "Neste aula abordaremos a estimação bayesiana de modelos de equilíbrio geral dinâmicas e estocásticos (DSGE no acrônimo em inglês)."
abstractspacing: double
keywords: DSGE
fontsize: 12pt
margin: 
urlcolor: darkblue
linkcolor: Mahogany
citecolor: Mahogany
spacing: double
papersize: a4paper
bibliography: references.bib
biblio-style: apalike
output:
  pdf_document: 
    citation_package: natbib
    fig_caption: yes
    keep_tex: yes
    number_sections: yes
    template: article-template.tex
---

[^JRCF]: Mestrado Profissional em Economia, Escola de Economia de São Paulo/Fundação Getúlio Vargas, [`joao.costa@fgv.br`](mailto:joao.costa@fgv.br), <https://sites.google.com/site/joaoricardocostafilho>.

```{r graphs, echo=FALSE, message=FALSE}
# set global chunk options
library(knitr)
opts_chunk$set(fig.path='figure/minimal-', fig.align='center', fig.show='hold')
options(formatR.arrow=TRUE,width=90)
```

\newpage

# Modelos DSGE com estimativa bayesiana

O exercício desta aula foi retirado de <http://gecon.r-forge.r-project.org/> e replicado fielmente. Nele é abordado um modelo da classe de RBC com governo e utilização da capacidade instalada.


```{r dsge, echo=TRUE, message=FALSE, eval=TRUE, warning=FALSE}
library(gEcon)
library(gEcon.estimation)

file.copy(from = file.path(system.file("examples", package = "gEcon.estimation"),
                           "dsge_model.gcn"), to = getwd())
dsge_model <- make_model("dsge_model.gcn")
```  

O arquivo \textit{dsge_model.gcn} contém o modelo:

```{r gecon, echo=TRUE, message=FALSE, eval=FALSE, warning=FALSE}  

# ############################################################################
# This file is a part of gEcon.estimation                                    #
#                                                                            #
# (c) Chancellery of the Prime Minister of the Republic of Poland 2012-2015  #
# (c) Grzegorz Klima, Karol Podemski 2015-2016                               #
# License terms can be found in the file 'LICENCE'                           #
#                                                                            #
# Authors: Karol Podemski                                                    #
# ############################################################################
# RBC model with variable capacity utilization and government                                                                 
# ############################################################################


options
{
    output logfile = TRUE;
    output LaTeX = TRUE;
    verbose = TRUE;
    output R long = TRUE;
}

tryreduce
{
    H_d[], PI[], lambda_U[], lambda_c[], T[], P[];
};

block CONSUMER
{
    definitions
    {
        u[] = log(C[]) + psi * log(1 - H[]);
    }
    controls
    {
        C[], H[];
    }
    objective
    {
        U[] = u[] + beta * E[][U[1]]    : lambda_U[];
    }
    constraints
    {
         C[] + T[] = W[] * H[] + PI[]       : lambda_c[];
    }
    calibration
    {
        beta = 0.99;
        psi = 1.75;
    }
}


block FIRM
{
    controls
    {
        K[], H_d[], Y[], I[], PI[], CapUt[];
    };
    objective
    {
        SPI[] = PI[] + E[][lambda_U[1] * lambda_c[1] / lambda_c[] * SPI[1]];
    };
    constraints
    {
        Y[] = exp(Z[]) ^ (1 - alpha) * (K[-1] * CapUt[])^alpha * (H_d[] )^(1 - alpha);
        K[] = (1 - delta * CapUt[] ^ omega) * K[-1]  + I[];
        PI[] = P[] * Y[] - H_d[] * W[] - I[];
    };
    identities
    {
        K_ut[] = CapUt[] * K[-1];
    };
    calibration
    {
        alpha = 0.33;
        omega = 1.45;
        delta = 0.0265;
    }
}


block EQUILIBRIUM
{
    identities
    {
        P[] = 1;
        H[] = H_d[];
    };
};

block GOVERNMENT
{
    identities
    {
        T[] = G[];
        G[] = phi_G * G[-1] + epsilon_G[];
    };
    shocks
    {
        epsilon_G[];
    };
    calibration
    {
        phi_G = 0.9;
    };
};

block EXOG 
{
    identities
    {    
        Z[] = phi_Z * Z[-1]  + epsilon_Z[];
    }
    shocks
    {           
        epsilon_Z[];
    }
    calibration
    {
        phi_Z = 0.9;
    }
};

```  

A partir dele, podemos resolver o modelo utilizando o pacote \textit{gEcon}. A estimativa bayesiana, via MCMC, utiliza o pactoe \textit{gEcon.estimation}.

```{r dsge2, echo=TRUE, message=FALSE, eval=TRUE, warning=FALSE}

# solve the model
dsge_model <- steady_state(dsge_model)
dsge_model <- solve_pert(dsge_model, loglin = TRUE)
# set the stochastic shocks distribution parameters
dsge_model <- set_shock_distr_par(dsge_model,
                                  distr_par = list("sd( epsilon_G )" = 0.01,
                                                   "sd( epsilon_Z )" = 0.01))
shock_info(model = dsge_model, all = TRUE)
```

A base de dados será criada a partir de simulações do modelo:

```{r dsge3, echo=TRUE, message=FALSE, eval=TRUE, warning=FALSE}
# ###################################################################
# 2. simulate the model to obtain data for the estimation
# choose variables of interest
set.seed(1301)
series_length <- 150
observables <- c("Y", "G")
# simulate random path
dsge_simulation <- random_path(model = dsge_model,
                               sim_length = series_length,
                               variables = observables)
model_data <- get_simulation_results(dsge_simulation)

# create data set to be used for estimation (ts object)
estimation_data <- ts(data = t(model_data)[, observables],
                      start = c(1973, 1),
                      frequency = 4, names = observables)
# remove mean from the data series
mean_var <- matrix(apply(estimation_data, 2, mean),
                   byrow = TRUE,
                   nrow = nrow(estimation_data),
                   ncol = ncol(estimation_data))
estimation_data <- estimation_data - mean_var
```

Para os parâmetros estimados, é necessário declarar a prior:

```{r dsge4, echo=TRUE, message=FALSE, eval=TRUE, warning=FALSE}

# ###################################################################
# 3. declare prior distribution
dsge_prior <- gecon_prior(
  prior_list = list(
    list(par = "sd(epsilon_Z)", type = "inv_gamma",
         mean = 0.012, sd = 0.3, lower_bound = 0.0001,
         upper_bound = 0.9, initial = 0.0012),
    list(par = "sd(epsilon_G)", type = "inv_gamma",
         mean = 0.008, sd = 0.3, lower_bound = 0.0001,
         upper_bound = 0.9, initial = 0.006),
    list(par = "omega", type = "normal",mean = 1.45, sd = 0.1, lower_bound = 1,
         upper_bound = 2, initial = 1.5),
    list(par = "phi_G", type = "beta",
         mean = 0.88, sd = 0.03, lower_bound = 0.5,
         upper_bound = 0.999, initial = 0.95),
    list(par = "phi_Z", type = "beta",
         mean = 0.92, sd = 0.03, lower_bound = 0.5,
         upper_bound = 0.999, initial = 0.95)),
  model = dsge_model)
plot_prior(dsge_prior)
```



```{r dsge5, echo=TRUE, message=FALSE, eval=TRUE, warning=FALSE}
# ###################################################################
# 4. estimate the model (Bayesian estimation)
estimation_result <- bayesian_estimation(data_set = estimation_data,
                     optim_options_list = list(solver = "csminwel"),
                     mcmc_options_list = list(chain_length = 1000,
                     burn = 200, cores = 2, chains = 2, scale = rep(0.5, 5)),
                     observables = observables, model = dsge_model,
                     prior = dsge_prior)
plot_posterior(estimation_result)


# csminwel: http://sims.princeton.edu/yftp/optimize/

# retrieve estimates
# true model parameters were:
# sd(epsilon_Z) 0.01
# sd(epsilon_G) 0.01
# omega 1.45
# phi_G 0.9
# phi_Z 0.9
est_par <- get_estimated_par(estimation_result)
free_par <- est_par$free_par
shock_distr_par <- est_par$shock_distr_par
estimated_dsge_model <- set_free_par(dsge_model, free_par = free_par)
estimated_dsge_model <- set_shock_distr_par(estimated_dsge_model, distr_par = shock_distr_par)
estimated_dsge_model <- steady_state(estimated_dsge_model)
estimated_dsge_model <- solve_pert(estimated_dsge_model, loglin = TRUE)

```


```{r dsge6, echo=TRUE, message=FALSE, eval=TRUE, warning=FALSE}

# ###################################################################
# 5. historical shock decomposition and variable smoothing
# find historical shock decomposition
dsge_shock_decomp <- shock_decomposition(model = estimated_dsge_model,
                                         data_set = window(estimation_data,
                                                           start = c(2004, 1),
                                                           end = c(2010, 1),
                                                           frequency = 4),
                                         observables = observables,
                                         variables = observables)
plot_shock_decomposition(dsge_shock_decomp)
# use Kalman smoother to obtain smoothed variables' values
dsge_smoothed_variables <- smoother(model = estimated_dsge_model,
                                    data_set = estimation_data,
                                    observables = c("Y", "G"),
                                    variables = c("K", "I", "C"))


# print smoothed shocks' values
dsge_smoothed_variables$smoothed_shock
# print smoothed variables' values
dsge_smoothed_variables$smoothed_var
# print the MSE matrix
dsge_smoothed_variables$MSE

```


```{r dsge7, echo=TRUE, message=FALSE, eval=TRUE, warning=FALSE}

# ###################################################################
# 6. forecast using the model
# forecast using point estimates of parameters
fc_res <- forecast(model = estimated_dsge_model,
                   data_set = estimation_data,
                   observables = observables,
                   variables = c("Y", "G"),
                   horizon = 20)

# forecast using posterior distribution
fc_res_post <- forecast_posterior(est_results = estimation_result,
                                  data_set = estimation_data,
                                  observables = observables,
                                  variables = c("Y", "G"),
                                  horizon = 20)

#"The forecast_posterior function allows to create forecasts by sampling parameter values from the posterior distribution, solving model, and simulating it for the n-periods ahead. The initial values of state variables for the forecast are obtained by the application of Kalman smoother."

# plot forecasts
plot_forecast(fc_res_post)
plot_forecast(fc_res)
```
